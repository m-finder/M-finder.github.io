---
title: php 国密 sm2 sm3 sm4 完整测试类
date: 2023-05-11 17:53:00
tags:
- 码不能停
- php
categories:
- 码不能停
- php
---

#### 应用范围及描述
| 算法类型 | 国密算法 | 应用范围及描述 |
|---|---|---|
| 对称加密 | SM1 | 128位数据加密，算法不公开，仅以IP核的形式存在于芯片中。智能IC卡、智能密码钥匙、加密卡、加密机。 |
| 非对称加密 | SM2 | 被用来替换RSA算法。常用于身份认证，数据签名，密码交换，256位椭圆曲线。 |
| 完整性运算 | SM3 | 256位数据摘要计算，相当于SHA256，数字签名及验证、消息认证码生成及验证、随机数生成 |
| 对称加密 | SM4 | 128位数据加密，相当于AES(128) |

#### 相关代码
php sm2 sm3 sm4 完整测试类，可拖入 laravel unit test 模块运行。基于扩展包 [[ lpilp/guomi ]](https://github.com/lpilp/phpsm2sm3sm4) , sm2 与兴业银行有部分区别，sm4 已互通，未做招行验证。
```php
<?php

namespace Tests\Unit;

use FG\ASN1\ASNObject;
use FG\ASN1\Exception\ParserException;
use Mdanter\Ecc\Crypto\Signature\Signature;
use Mdanter\Ecc\Serializer\Signature\DerSignatureSerializer;
use PHPUnit\Framework\TestCase;
use Rtgm\sm\RtSm2;
use Rtgm\sm\RtSm3;
use Rtgm\sm\RtSm4;

/**
 * 国密加密测试
 * sm4 已与兴业银行调通
 */
class GmTest extends TestCase
{


    /**
     * 获取 sm2
     * @return RtSm2
     */
    private function getSm2(): RtSm2
    {
        return new RtSm2('base64');
    }

    /**
     * 获取 sm3
     * @return RtSm3
     */
    private function getSm3(): RtSm3
    {
        return new RtSm3();
    }

    /**
     * 获取 sm4
     * @return RtSm4
     */
    private function getSm4(): RtSm4
    {
        $privateKey = $this->getSm4PrivateKey();

        return new RtSm4($privateKey);
    }

    /**
     * 获取 16进制 base64 decode sm2 密钥
     * 生成于工具站 https://www.lzltool.com/SM2 base64格式
     * @return string
     */
    private function getSm2PrivateKey(): string
    {
        return bin2hex(base64_decode('L8TbMByc+rQmKECWMBjnDQHrXrExqZKdl5S6sBbP07M='));
    }

    /**
     * 获取 16进制 base64 decode sm2 公钥
     * 生成于工具站 https://www.lzltool.com/SM2 base64格式
     * @return string
     */
    private function getSm2PublicKey(): string
    {
        return bin2hex(base64_decode('BCxc4cDX1OQEpCD8O7wzPhTOljYg0uzfsMAEanCvYgBIj966+i5pgjwyIOtFSNWLWjoDzLmMJP9nf2cVmiH+aYI='));
    }

    /**
     * sm2 数据格式化
     * @param $dec
     * @return string
     */
    private function sm2FormatHex($dec): string
    {
        $hex = gmp_strval(gmp_init($dec, 10), 16);
        $len = strlen($hex);
        if ($len == 64) {
            return $hex;
        }

        return $len < 64 ? str_pad($hex, 64, "0", STR_PAD_LEFT) : substr($hex, $len - 64, 64);
    }

    /**
     * 获取 base64 decode 密钥
     * @return bool|string
     */
    private function getSm4PrivateKey(): bool|string
    {
        return base64_decode('NmQzZDQ2YTcxMmRjNGE0NQ==');
    }


    /**
     * 获取待加密字符串
     * @return string
     */
    private function getDataStr(): string
    {
        return '{"bankCardNo":"6212028190240439021","certNo":"41052619700925136X","userName":"南瓜"}';
    }

    /**
     * 拼接 sm2 待加密字符串
     * @return bool|string
     */
    private function getSm2SignStr(): bool|string
    {
        $params = json_decode($this->getDataStr(), true);
        $signStr = '';
        if ($params != null) {
            ksort($params);
            foreach ($params as $k => $v) {
                $signStr .= "{$k}={$v}&";
            }
        }
        return substr($signStr, 0, strlen($signStr) - 1);
    }

    public function test_sm2_encrypt()
    {
        $sm2 = $this->getSm2();

        $signStr = $this->getSm2SignStr();

        // 加密
        $sign = $sm2->doSign($signStr, $this->getSm2PrivateKey());
        $encryptStr = base64_decode($sign);

        try {
            $a = ASNObject::fromBinary($encryptStr)->getChildren();
        } catch (ParserException $e) {
            $this->fail('加密失败: ' . $e->getMessage());
        }

        $aa = $this->sm2FormatHex($a[0]->getContent());
        $bb = $this->sm2FormatHex($a[1]->getContent());
        $encryptStr = base64_encode(hex2bin($aa . $bb));
        $this->assertNotEmpty($encryptStr);

        return $encryptStr;
    }

    public function test_sm2_decrypt()
    {
        $sm2 = $this->getSm2();
        $encryptSignStr = bin2hex(base64_decode($this->test_sm2_encrypt()));
        echo 'sm2 sign str: ', $encryptSignStr, PHP_EOL;

        $r = substr($encryptSignStr, 0, 64);
        $s = substr($encryptSignStr, 64, 64);
        $r = gmp_init($r, 16);
        $s = gmp_init($s, 16);
        $signature = new Signature($r, $s);
        $serializer = new DerSignatureSerializer();
        $sign = base64_encode($serializer->serialize($signature));

        $boolean = $sm2->verifySign($this->getSm2SignStr(), $sign, $this->getSm2PublicKey()) ?? false;
        echo $boolean ? 'sm2 验签通过' : 'sm2 验签失败', PHP_EOL;
        $this->assertTrue($boolean);
    }



    public function test_sm3()
    {
        $sm3 = $this->getSm3();
        $signStr = $sm3->digest($this->getDataStr());
        echo 'sm3 sign str: ', $signStr, PHP_EOL;
        $this->assertNotEmpty($signStr);
    }

    /**
     * 测试 byteArr to string
     * @return string
     */
    public function test_sm4_iv()
    {
        $byteArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        $iv = call_user_func_array('pack', array_merge(['C*'], $byteArr));

        $this->assertTrue(base64_encode($iv) === 'AAAAAAAAAAAAAAAAAAAAAA==');

        return base64_encode($iv);
    }

    public function test_sm4_encrypt()
    {
        try {
            $iv = $this->test_sm4_iv();
            $sm4 = $this->getSm4();
            $encryptJsonStr = $sm4->encrypt($this->getDataStr(), 'sm4', base64_decode($iv));
        } catch (\Exception $e) {
            $this->fail('加密异常：' . $e->getMessage());
        }

        $encryptJsonStr = base64_encode(hex2bin($encryptJsonStr));
        $this->assertNotEmpty($encryptJsonStr);

        return $encryptJsonStr;
    }

    public function test_sm4_decrypt()
    {
        try {
            $sm4 = $this->getSm4();
            $encryptJsonStr = $this->test_sm4_encrypt();
            echo "sm4 encrypt str:  " . $encryptJsonStr, PHP_EOL;
            $decryptJsonStr = $sm4->decrypt(bin2hex(base64_decode($encryptJsonStr)), 'sm4', base64_decode($this->test_sm4_iv()));
        } catch (\Exception $e) {
            $this->fail('解密异常：' . $e->getMessage());
        }

        echo "sm4 decrypt str:  " . $decryptJsonStr, PHP_EOL;
        echo $decryptJsonStr === $this->getDataStr() ? 'sm4 数据一致' : 'sm4 数据不一致', PHP_EOL;
        $this->assertNotEmpty($decryptJsonStr);
    }
}
```